/* globals describe it beforeEach */

/**
 * Auth signature compatibility tests
 *
 * These tests verify that our SDK generates signatures compatible with
 * the Pandora contract by testing against known
 * reference signatures generated from Solidity.
 */

import { assert } from 'chai'
import { ethers } from 'ethers'
import { PDPAuthHelper } from '../pdp/auth.js'
import type { RootData } from '../types.js'

// Test fixtures generated from Solidity reference implementation
// These signatures are verified against Pandora contract
const FIXTURES = {
  // Test private key from Solidity (never use in production!)
  privateKey: '0x1234567890123456789012345678901234567890123456789012345678901234',
  signerAddress: '0x2e988A386a799F506693793c6A5AF6B54dfAaBfB',
  contractAddress: '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f',
  chainId: 31337,
  domainSeparator: '0xc8fab2af8a94242cb941b37088d380710d98d07afc2db8a90c1b74c8d47220b0',

  // EIP-712 domain separator components
  domain: {
    name: 'PandoraService',
    version: '1',
    chainId: 31337,
    verifyingContract: '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f'
  },

  // Expected EIP-712 signatures generated by Solidity reference
  signatures: {
    createProofSet: {
      signature: '0x69addf4632ef95bfae97137421ba09576f9c55b12219e2c90442cbc1524421247b373dfad6e59256f87256f08220b0c008bbab7cdaceb1dd51454de094a7ffa51b',
      digest: '0xf9505c69c8af50c0c3535d4436cca739abd9be143f980d9affc796a859c12679',
      clientDataSetId: 12345,
      payee: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
      withCDN: true
    },
    addRoots: {
      signature: '0x4d873bfc7e03792bf262434673d3f58cebaa5ecd1d81ff4d1974e3ef382e7ac40192c2973f7ec7895cfb0963b330dfa236c4c15093d3c136e321587d77c926f31b',
      digest: '0xeca924d5b1f71837d58bf8dd8c11a71a042d35e4804e8d1fbff282c5daa5cc2a',
      clientDataSetId: 12345,
      firstAdded: 1,
      rootDigests: [
        '0xfc7e928296e516faade986b28f92d44a4f24b935485223376a799027bc18f833',
        '0xa9eb89e9825d609ab500be99bf0770bd4e01eeaba92b8dad23c08f1f59bfe10f'
      ],
      rootSizes: [1024, 2048]
    },
    scheduleRemovals: {
      signature: '0xe092fd8b6110a4914c0be071d14c1a2c838eb61bf3cb3661e9650da241a22e2d583b7c707eace2f80c9879e123906e02ca5a1eb66d162eaa13d1b7fd19d6db341c',
      digest: '0x43f04e097c15cd3d0ce855797c63857e886e8b0745aea9379cf2fb07bea10235',
      clientDataSetId: 12345,
      rootIds: [1, 3, 5]
    },
    deleteProofSet: {
      signature: '0x093fae193f81a7fe72d2124ed9d70337747458ac2d568c5b9a42072782adb7c4393f49b2f3bce9a84d94ee2c93ef4c9af8c0b258be3bde3f8df0536fa4eea65b1c',
      digest: '0x07facb576326aebcfe7d009f08a5161e916046dd13a413c06a914572cb5fc109',
      clientDataSetId: 12345
    }
  }
}

// Helper to create CommP CIDs from the test root digests
const ROOT_DATA: RootData[] = [
  {
    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy', // digest: 0xfc7e92...
    rawSize: 1024
  },
  {
    cid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy', // digest: 0xa9eb89...
    rawSize: 2048
  }
]

describe('Auth Signature Compatibility', () => {
  let authHelper: PDPAuthHelper
  let signer: ethers.Wallet

  beforeEach(() => {
    // Create signer from test private key
    signer = new ethers.Wallet(FIXTURES.privateKey)

    // Create PDPAuthHelper with test contract address and chain ID
    authHelper = new PDPAuthHelper(FIXTURES.contractAddress, signer, BigInt(FIXTURES.chainId))

    // Verify test setup
    assert.strictEqual(signer.address, FIXTURES.signerAddress)
  })

  it('should generate CreateProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature,
      'CreateProofSet signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate AddRoots signature matching Solidity reference', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      ROOT_DATA
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.addRoots.signature,
      'AddRoots signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate ScheduleRemovals signature matching Solidity reference', async () => {
    const result = await authHelper.signScheduleRemovals(
      FIXTURES.signatures.scheduleRemovals.clientDataSetId,
      FIXTURES.signatures.scheduleRemovals.rootIds
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.scheduleRemovals.signature,
      'ScheduleRemovals signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate DeleteProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signDeleteProofSet(
      FIXTURES.signatures.deleteProofSet.clientDataSetId
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.deleteProofSet.signature,
      'DeleteProofSet signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should handle bigint values correctly', async () => {
    const result = await authHelper.signCreateProofSet(
      BigInt(12345), // Use bigint instead of number
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Should produce same signature as number version
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature)
  })

  it('should generate consistent signatures', async () => {
    // Generate same signature multiple times
    const sig1 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    const sig2 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Signatures should be identical (deterministic)
    assert.strictEqual(sig1.signature, sig2.signature)
    assert.strictEqual(sig1.signedData, sig2.signedData)
  })

  it('should handle empty root data array', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      [] // empty array
    )

    // Should generate valid signature (different from test fixture)
    assert.match(result.signature, /^0x[0-9a-f]{130}$/i)
    assert.isDefined(result.signedData)

    // Should be able to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })
})
