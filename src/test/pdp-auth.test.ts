/* globals describe it beforeEach */

/**
 * Auth signature compatibility tests
 *
 * These tests verify that our SDK generates signatures compatible with
 * the SimplePDPServiceWithPayments contract by testing against known
 * reference signatures generated from Solidity.
 */

import { assert } from 'chai'
import { ethers } from 'ethers'
import { PDPAuthHelper } from '../pdp/auth.js'
import type { RootData } from '../types.js'

// Test fixtures from Solidity contract (filecoin-services/service_contracts)
// Generated using SignatureFixtureTest.t.sol with known private key
const FIXTURES = {
  // Test private key from Solidity (never use in production!)
  privateKey: '0x1234567890123456789012345678901234567890123456789012345678901234',
  signerAddress: '0x2e988A386a799F506693793c6A5AF6B54dfAaBfB',
  contractAddress: '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f',

  // Expected signatures generated by Solidity contract
  signatures: {
    createProofSet: {
      signature: '0x7486153ac70abc0b45f07cfa3d966505bce69104d277402f5111a54c36c0266222947952867ac4365ae79263a04639bb2ff9c2a92b12e54b9b910fe2ff89fc7c1b',
      clientDataSetId: 12345,
      payee: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
      withCDN: true
    },
    addRoots: {
      signature: '0xc939c6e9d1c685cf23f966f3b462b9db48b280533e99e44577d397ba43fe917c03b8ab99c2650f203f7479ee3bf9f1bc259505fb30654d7dd920eac6950a77261c',
      clientDataSetId: 12345,
      firstAdded: 1,
      rootDigests: [
        '0xfc7e928296e516faade986b28f92d44a4f24b935485223376a799027bc18f833',
        '0xa9eb89e9825d609ab500be99bf0770bd4e01eeaba92b8dad23c08f1f59bfe10f'
      ],
      rootSizes: [1024, 2048]
    },
    scheduleRemovals: {
      signature: '0xdd0c885ebd532034fa1b442193ea6f6b6480d8fbcf1d29dc5eae0cc2eeea468850ea022d2693009231aff0a1dfd59f69adf6389a771f6e6d88e0e4a8d9b1f4e31b',
      clientDataSetId: 12345,
      rootIds: [1, 3, 5]
    },
    deleteProofSet: {
      signature: '0x614385d6a5fe4c3bc4693adf25fa4e81ec64af49c8ea40e058cb90f91c026d305083801f25a84b1dcfa9525034aaeaeadca89a5f5fb01b2257d59d2c2b99f4701b',
      clientDataSetId: 12345
    }
  }
}

// Helper to create CommP CIDs from the test root digests
const ROOT_DATA: RootData[] = [
  {
    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy', // digest: 0xfc7e92...
    rawSize: 1024
  },
  {
    cid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy', // digest: 0xa9eb89...
    rawSize: 2048
  }
]

describe('Auth Signature Compatibility', () => {
  let authHelper: PDPAuthHelper
  let signer: ethers.Wallet

  beforeEach(() => {
    // Create signer from test private key
    signer = new ethers.Wallet(FIXTURES.privateKey)

    // Create PDPAuthHelper with test contract address
    authHelper = new PDPAuthHelper(FIXTURES.contractAddress, signer)

    // Verify test setup
    assert.strictEqual(signer.address, FIXTURES.signerAddress)
  })

  it('should generate CreateProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature,
      'CreateProofSet signature should match Solidity reference')

    // Verify signature components
    assert.strictEqual(result.v, 27)
    assert.strictEqual(result.r, '0x7486153ac70abc0b45f07cfa3d966505bce69104d277402f5111a54c36c02662')
    assert.strictEqual(result.s, '0x22947952867ac4365ae79263a04639bb2ff9c2a92b12e54b9b910fe2ff89fc7c')

    // Verify signed data can be used to recover signer
    const messageHash = ethers.keccak256(result.signedData)
    const recoveredSigner = ethers.recoverAddress(messageHash, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate AddRoots signature matching Solidity reference', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      ROOT_DATA
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.addRoots.signature,
      'AddRoots signature should match Solidity reference')

    // Verify signature components
    assert.strictEqual(result.v, 28)
    assert.strictEqual(result.r, '0xc939c6e9d1c685cf23f966f3b462b9db48b280533e99e44577d397ba43fe917c')
    assert.strictEqual(result.s, '0x03b8ab99c2650f203f7479ee3bf9f1bc259505fb30654d7dd920eac6950a7726')

    // Verify signed data can be used to recover signer
    const messageHash = ethers.keccak256(result.signedData)
    const recoveredSigner = ethers.recoverAddress(messageHash, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate ScheduleRemovals signature matching Solidity reference', async () => {
    const result = await authHelper.signScheduleRemovals(
      FIXTURES.signatures.scheduleRemovals.clientDataSetId,
      FIXTURES.signatures.scheduleRemovals.rootIds
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.scheduleRemovals.signature,
      'ScheduleRemovals signature should match Solidity reference')

    // Verify signature components
    assert.strictEqual(result.v, 27)
    assert.strictEqual(result.r, '0xdd0c885ebd532034fa1b442193ea6f6b6480d8fbcf1d29dc5eae0cc2eeea4688')
    assert.strictEqual(result.s, '0x50ea022d2693009231aff0a1dfd59f69adf6389a771f6e6d88e0e4a8d9b1f4e3')

    // Verify signed data can be used to recover signer
    const messageHash = ethers.keccak256(result.signedData)
    const recoveredSigner = ethers.recoverAddress(messageHash, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate DeleteProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signDeleteProofSet(
      FIXTURES.signatures.deleteProofSet.clientDataSetId
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.deleteProofSet.signature,
      'DeleteProofSet signature should match Solidity reference')

    // Verify signature components
    assert.strictEqual(result.v, 27)
    assert.strictEqual(result.r, '0x614385d6a5fe4c3bc4693adf25fa4e81ec64af49c8ea40e058cb90f91c026d30')
    assert.strictEqual(result.s, '0x5083801f25a84b1dcfa9525034aaeaeadca89a5f5fb01b2257d59d2c2b99f470')

    // Verify signed data can be used to recover signer
    const messageHash = ethers.keccak256(result.signedData)
    const recoveredSigner = ethers.recoverAddress(messageHash, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should handle bigint values correctly', async () => {
    const result = await authHelper.signCreateProofSet(
      BigInt(12345), // Use bigint instead of number
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Should produce same signature as number version
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature)
  })

  it('should generate consistent signatures', async () => {
    // Generate same signature multiple times
    const sig1 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    const sig2 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Signatures should be identical (deterministic)
    assert.strictEqual(sig1.signature, sig2.signature)
    assert.strictEqual(sig1.signedData, sig2.signedData)
  })

  it('should handle empty root data array', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      [] // empty array
    )

    // Should generate valid signature (different from test fixture)
    assert.match(result.signature, /^0x[0-9a-f]{130}$/i)
    assert.isDefined(result.signedData)

    // Should be able to recover signer
    const messageHash = ethers.keccak256(result.signedData)
    const recoveredSigner = ethers.recoverAddress(messageHash, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })
})
