/* globals describe it beforeEach */

/**
 * Auth signature compatibility tests
 *
 * These tests verify that our SDK generates signatures compatible with
 * the SimplePDPServiceWithPayments contract by testing against known
 * reference signatures generated from Solidity.
 */

import { assert } from 'chai'
import { ethers } from 'ethers'
import { PDPAuthHelper } from '../pdp/auth.js'
import type { RootData } from '../types.js'

// Test fixtures generated from Solidity reference implementation
// These signatures are verified against SimplePDPServiceWithPayments contract
const FIXTURES = {
  // Test private key from Solidity (never use in production!)
  privateKey: '0x1234567890123456789012345678901234567890123456789012345678901234',
  signerAddress: '0x2e988A386a799F506693793c6A5AF6B54dfAaBfB',
  contractAddress: '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f',
  chainId: 31337,
  domainSeparator: '0x312b13e9da42067b2f99ecbbad4848c401ec0496e44e8b48798cf576ceea31c0',

  // EIP-712 domain separator components
  domain: {
    name: 'SimplePDPServiceWithPayments',
    version: '1',
    chainId: 31337,
    verifyingContract: '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f'
  },

  // Expected EIP-712 signatures generated by Solidity reference
  signatures: {
    createProofSet: {
      signature: '0x359024e8f3957f49da9ac21cef46bee1d24bdd159b0ea0f454971b791a3e06a65a511950da6e65b664dddad98326cef975c6b2144a372bc1fde39ec108db64b61c',
      digest: '0xf9505c69c8af50c0c3535d4436cca739abd9be143f980d9affc796a859c12679',
      clientDataSetId: 12345,
      payee: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
      withCDN: true
    },
    addRoots: {
      signature: '0xbc94f2d4a61d33025e6794405b6022bc091b7a6011aa5b5c1c9af70611091b641fb33c144bea0666fd28980999cc7e8749f29c25cef10ed075c69f3034df43bc1c',
      digest: '0xeca924d5b1f71837d58bf8dd8c11a71a042d35e4804e8d1fbff282c5daa5cc2a',
      clientDataSetId: 12345,
      firstAdded: 1,
      rootDigests: [
        '0xfc7e928296e516faade986b28f92d44a4f24b935485223376a799027bc18f833',
        '0xa9eb89e9825d609ab500be99bf0770bd4e01eeaba92b8dad23c08f1f59bfe10f'
      ],
      rootSizes: [1024, 2048]
    },
    scheduleRemovals: {
      signature: '0x22c6669700d387f17f82098cfe09163eb6a11c21ce2befe2fcd832a63544572a2fa9ce673b448a0f4dec1dbb6da2f53baaa412be09ad71c501aca47bcd43cd4b1c',
      digest: '0x43f04e097c15cd3d0ce855797c63857e886e8b0745aea9379cf2fb07bea10235',
      clientDataSetId: 12345,
      rootIds: [1, 3, 5]
    },
    deleteProofSet: {
      signature: '0x4b5f391dc87a1f1eab3d201e0caabda9739aef81dcac770bff5d1e79687aeacd53863438f6ee0377c49bda974dfa51b1a7ad6df08e26497cbe8f1dedabe952c51b',
      digest: '0x07facb576326aebcfe7d009f08a5161e916046dd13a413c06a914572cb5fc109',
      clientDataSetId: 12345
    }
  }
}

// Helper to create CommP CIDs from the test root digests
const ROOT_DATA: RootData[] = [
  {
    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy', // digest: 0xfc7e92...
    rawSize: 1024
  },
  {
    cid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy', // digest: 0xa9eb89...
    rawSize: 2048
  }
]

describe('Auth Signature Compatibility', () => {
  let authHelper: PDPAuthHelper
  let signer: ethers.Wallet

  beforeEach(() => {
    // Create signer from test private key
    signer = new ethers.Wallet(FIXTURES.privateKey)

    // Create PDPAuthHelper with test contract address and chain ID
    authHelper = new PDPAuthHelper(FIXTURES.contractAddress, signer, BigInt(FIXTURES.chainId))

    // Verify test setup
    assert.strictEqual(signer.address, FIXTURES.signerAddress)
  })

  it('should generate CreateProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature,
      'CreateProofSet signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate AddRoots signature matching Solidity reference', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      ROOT_DATA
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.addRoots.signature,
      'AddRoots signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate ScheduleRemovals signature matching Solidity reference', async () => {
    const result = await authHelper.signScheduleRemovals(
      FIXTURES.signatures.scheduleRemovals.clientDataSetId,
      FIXTURES.signatures.scheduleRemovals.rootIds
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.scheduleRemovals.signature,
      'ScheduleRemovals signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate DeleteProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signDeleteProofSet(
      FIXTURES.signatures.deleteProofSet.clientDataSetId
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.deleteProofSet.signature,
      'DeleteProofSet signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should handle bigint values correctly', async () => {
    const result = await authHelper.signCreateProofSet(
      BigInt(12345), // Use bigint instead of number
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Should produce same signature as number version
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature)
  })

  it('should generate consistent signatures', async () => {
    // Generate same signature multiple times
    const sig1 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    const sig2 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Signatures should be identical (deterministic)
    assert.strictEqual(sig1.signature, sig2.signature)
    assert.strictEqual(sig1.signedData, sig2.signedData)
  })

  it('should handle empty root data array', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      [] // empty array
    )

    // Should generate valid signature (different from test fixture)
    assert.match(result.signature, /^0x[0-9a-f]{130}$/i)
    assert.isDefined(result.signedData)

    // Should be able to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })
})
