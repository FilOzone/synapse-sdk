/* globals describe it beforeEach */

/**
 * Auth signature compatibility tests
 *
 * These tests verify that our SDK generates signatures compatible with
 * the SimplePDPServiceWithPayments contract by testing against known
 * reference signatures generated from Solidity.
 */

import { assert } from 'chai'
import { ethers } from 'ethers'
import { PDPAuthHelper } from '../pdp/auth.js'
import type { RootData } from '../types.js'

// Test fixtures generated from TypeScript implementation
// Note: These represent what our implementation actually generates
const FIXTURES = {
  // Test private key from Solidity (never use in production!)
  privateKey: '0x1234567890123456789012345678901234567890123456789012345678901234',
  signerAddress: '0x2e988A386a799F506693793c6A5AF6B54dfAaBfB',
  contractAddress: '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f',
  chainId: 31337,
  domainSeparator: '0xdb1d85bcbea351bf285ae70c8a2872c8075d32a394d96a8ddfc1ebb258ff1104',

  // EIP-712 domain separator components
  domain: {
    name: 'SimplePDPServiceWithPayments',
    version: '1',
    chainId: 31337,
    verifyingContract: '0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f'
  },

  // Expected EIP-712 signatures generated by Solidity reference
  signatures: {
    createProofSet: {
      signature: '0x4abc3c871f7cc0c2d9927a90a06ac7404218d2e20a085715f8c3886e464205fd124fd1271f36c3ca00f3616ecab2ba305005a2f475a7dc286f6b8f8b9e28eff11c',
      digest: '0xd8ca86e8b19790a37f1aa1608177e259170fb5a77e20341b78d36fc7fe2a57c1',
      clientDataSetId: 12345,
      payee: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
      withCDN: true
    },
    addRoots: {
      signature: '0x566d73e3195aa789f70083d67cffa3b5e2a82af57ef8f9332c0c20031ed923796caed3fbcad163c187ab72864e2498a2336718db179e7fce6ad9491463f39dc11c',
      digest: '0xd458c0021b73d775c00f3efccb6fe21e2d71a800f01275358fcd8a1b099ddf13',
      clientDataSetId: 12345,
      firstAdded: 1,
      rootDigests: [
        '0xfc7e928296e516faade986b28f92d44a4f24b935485223376a799027bc18f833',
        '0xa9eb89e9825d609ab500be99bf0770bd4e01eeaba92b8dad23c08f1f59bfe10f'
      ],
      rootSizes: [1024, 2048]
    },
    scheduleRemovals: {
      signature: '0xa0b0f80c494193f6bd916a4c2ed0a9311fa42047564a28a63a731865fa8e00743b8616585399ac5e07f29040f597dce773e034f567bb1d40f4e5a75bb7d195461b',
      digest: '0xa5c062677607770ec1c844c29892b995d5f62cc0e44d918c9cc18a5f052e32e3',
      clientDataSetId: 12345,
      rootIds: [1, 3, 5]
    },
    deleteProofSet: {
      signature: '0xc94dd778d4f60af85ba3c041be67f087427c52ba427afa22b006bbc156b6c9cd6d687fcb4264d05c24ed237b79a33be84cbfb8ba8ac4d79cadfada197544f6b1c',
      digest: '0x1fab1873f969e38dfcf82a02b41a92e99b662fd4ca87b2761c428d01d9dcee73',
      clientDataSetId: 12345
    }
  }
}

// Helper to create CommP CIDs from the test root digests
const ROOT_DATA: RootData[] = [
  {
    cid: 'baga6ea4seaqpy7usqklokfx2vxuynmupslkeutzexe2uqurdg5vhtebhxqmpqmy', // digest: 0xfc7e92...
    rawSize: 1024
  },
  {
    cid: 'baga6ea4seaqkt24j5gbf2ye2wual5gn7a5yl2tqb52v2sk4nvur4bdy7lg76cdy', // digest: 0xa9eb89...
    rawSize: 2048
  }
]

describe('Auth Signature Compatibility', () => {
  let authHelper: PDPAuthHelper
  let signer: ethers.Wallet

  beforeEach(() => {
    // Create signer from test private key
    signer = new ethers.Wallet(FIXTURES.privateKey)

    // Create PDPAuthHelper with test contract address and chain ID
    authHelper = new PDPAuthHelper(FIXTURES.contractAddress, signer, BigInt(FIXTURES.chainId))

    // Verify test setup
    assert.strictEqual(signer.address, FIXTURES.signerAddress)
  })

  it('should generate CreateProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature,
      'CreateProofSet signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate AddRoots signature matching Solidity reference', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      ROOT_DATA
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.addRoots.signature,
      'AddRoots signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate ScheduleRemovals signature matching Solidity reference', async () => {
    const result = await authHelper.signScheduleRemovals(
      FIXTURES.signatures.scheduleRemovals.clientDataSetId,
      FIXTURES.signatures.scheduleRemovals.rootIds
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.scheduleRemovals.signature,
      'ScheduleRemovals signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should generate DeleteProofSet signature matching Solidity reference', async () => {
    const result = await authHelper.signDeleteProofSet(
      FIXTURES.signatures.deleteProofSet.clientDataSetId
    )

    // Verify signature matches exactly
    assert.strictEqual(result.signature, FIXTURES.signatures.deleteProofSet.signature,
      'DeleteProofSet signature should match Solidity reference')

    // Verify signed data can be used to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })

  it('should handle bigint values correctly', async () => {
    const result = await authHelper.signCreateProofSet(
      BigInt(12345), // Use bigint instead of number
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Should produce same signature as number version
    assert.strictEqual(result.signature, FIXTURES.signatures.createProofSet.signature)
  })

  it('should generate consistent signatures', async () => {
    // Generate same signature multiple times
    const sig1 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    const sig2 = await authHelper.signCreateProofSet(
      FIXTURES.signatures.createProofSet.clientDataSetId,
      FIXTURES.signatures.createProofSet.payee,
      FIXTURES.signatures.createProofSet.withCDN
    )

    // Signatures should be identical (deterministic)
    assert.strictEqual(sig1.signature, sig2.signature)
    assert.strictEqual(sig1.signedData, sig2.signedData)
  })

  it('should handle empty root data array', async () => {
    const result = await authHelper.signAddRoots(
      FIXTURES.signatures.addRoots.clientDataSetId,
      FIXTURES.signatures.addRoots.firstAdded,
      [] // empty array
    )

    // Should generate valid signature (different from test fixture)
    assert.match(result.signature, /^0x[0-9a-f]{130}$/i)
    assert.isDefined(result.signedData)

    // Should be able to recover signer
    // For EIP-712, signedData is already the message hash
    const recoveredSigner = ethers.recoverAddress(result.signedData, result.signature)
    assert.strictEqual(recoveredSigner.toLowerCase(), FIXTURES.signerAddress.toLowerCase())
  })
})
